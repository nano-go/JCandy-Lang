package com.nano.candy.interpreter.cni;

import com.nano.candy.interpreter.builtin.CandyObject;
import java.lang.reflect.Method;

/**
 * We use the annotation processor to generate Java files that contains
 * a register method used to generate a series of JavaMethodObj.
 *
 * The generated class (every Java file contains a public class) name is
 * generated by the original class that the annotated methods are defined in.
 *
 * We gets those JavaMethodObj objects by relfection.
 *
 * <pre>
 * The annotation is {@link NativeMethod}.
 * <pre>
 */
public class NativeMethodRegister {
	
	public static JavaMethodObj[] generateNativeMethods(String className, 
	                                                    Class<? extends CandyObject> clazz) {
		String klassName = clazz.getCanonicalName();
		String resgiterClassName = klassName + "_MetsRegister";
		Class<?> registerClass;
		try {
			registerClass = Class.forName(resgiterClassName, 
										  true, clazz.getClassLoader());
		} catch (ClassNotFoundException e) {
			// Means there are no native methods defined in the class.
			return new JavaMethodObj[0];
		}
		try {
			// JavaMethodObj[] register(String)
			Method method = registerClass.getMethod("register", String.class);
			return (JavaMethodObj[]) method.invoke(null, className);
		} catch (NoSuchMethodException e) {
			throw new IllegalArgumentException(
				"The class " + registerClass.getCanonicalName() + " has no" +
				" resgiter method.");
		} catch (SecurityException e) {
			throw new IllegalArgumentException(e.getMessage());
		} catch (Exception e) {
			throw new IllegalStateException(e.getMessage());
		}
	}
}
